// Core primitives
//
def(lambda, parameters\, body,
  primitive('lambda')
)

def(macro, pattern, body,
  primitive('macro')
)

def(`, expr,
  primitive('`')
)

def(defined?, name,
  primitive('defined?')
)

def(lcurry, fn, params\,
  primitive('lcurry')
)

def(rcurry, fn, params\,
  primitive('rcurry')
)

def(ncurry, fn, index, param,
  primitive('ncurry')
)

def(eval, expression,
  primitive('eval')
)

def(apply, function, params\,
  primitive('apply')
)

// Comparison operators
//
def(=, name, value,
  primitive('=')
)

def(==, lexpr, rexpr,
  primitive('==')
)

def(!=, lexpr, rexpr,
  primitive('!=')
)

def(<, lexpr, rexpr,
  primitive('<')
)

def(>, lexpr, rexpr,
  primitive('>')
)

def(<=, lexpr, rexpr,
  primitive('<=')
)

def(>=, lexpr, rexpr,
  primitive('>=')
)

def(!, lexpr, rexpr,
  primitive('!')
)

def(&&, lexpr, rexpr,
  primitive('&&')
)

def(||, lexpr, rexpr,
  primitive('||')
)



// Expressions inspection
//
def(applic?, expression,
  primitive('applic?')
)

def(applied, application,
  primitive('applied')
)

def(params, application,
  primitive('params')
)

def(nthParam, application, index,
  primitive('nthParam')
)

// Control and data structures
//

def(L, elements\,
  primitive('L')
)

def(H, elements\,
  primitive('H')
)

def(X, elements\,
  primitive('X')
)

def(if, predicate, consequence, opposite?,
  primitive('if')
)

def(for, listOrInit, lambdaOrStopCond, incrementExpr?, body?,
  primitive('for')
)


def(join, list, separator?,
  primitive('join')
)

// Shell
//

def(prit, elements\,
  primitive('prit')
)

def(print, elements\,
  prit(elements\, "\n")
)

def(load, file,
  primitive('load')
)

def(arguments,
  primitive('arguments')
)

// Package management
//

def(package, name, body,
  primitive('package')
)

def(import, name,
  primitive('import')
)

def(::, package, definition,
  primitive('::')
)

// Operators notations, order is establishing precedence
//
macro(`a = `b,
  if(applic?(a),
    if(applied(a) == "@", 
      `(@!($(nthParam(a, 0)), $(nthParam(a,1)), $b)) ),
    `(=($a, $b))
  )
)

// Defining macrox as a shorthand form of macro where
// the body is always escaped.
macro(macrox(`exp, `body), `(macro($exp, `($body))))

macrox(`a && `b, &&($a, $b))
macrox(`a || `b, ||($a, $b))

macrox(`a == `b, ==($a, $b))
macrox(`a != `b, !=($a, $b))
macrox(`a < `b, <($a, $b))
macrox(`a <= `b, <=($a, $b))
macrox(`a > `b, >($a, $b))
macrox(`a >= `b, >=($a, $b))
macrox(`a =~ `b, =~($a, $b))

macrox(`a += `b, =($a, +($a, $b)))
macrox(`a -= `b, =($a, -($a, $b)))
macrox(`a + `b, +($a, $b))
macrox(`a - `b, -($a, $b))
macrox(`a * `b, *($a, $b))
macrox(`a / `b, /($a, $b))

// Standard parsing for foo@bar(baz) is foo@(bar(baz)). We want (foo@bar)(baz).
macro(`arr . `idx, 
  if(applic?(idx),
    // TODO simplify
    if(empty?(params(idx)),
      `( @($arr, $(applied(idx)))() ),
      `( @($arr, $(applied(idx)))($<(params(idx))) )
    ),
    `(@($arr, $idx))
  )
)

macro(`pack :: `def, 
  if(applic?(def),
    if(empty?(params(def)),
      `( ::($pack, $(applied(def)))() ),
      `( ::($pack, $(applied(def)))($<(params(def))) )
    ),
    `(::($pack, $def))
  )
)

// TODO let with variable number of var/val pairs
macro(let(`var, `val, `block), `(lambda($var, $block)($val)))

LanguageErrors = [ReferenceError, NameError, CallError, TypeError]
