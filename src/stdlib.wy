def(lambda, parameters\, body,
  primitive('lambda')
)

def(macro, pattern, body,
  primitive('macro')
)

def(`, expr,
  primitive('`')
)

def(defined?, name,
  primitive('defined?')
)

def(eval, expression,
  primitive('eval')
)

def(apply, function, params\,
  primitive('apply')
)

// Control and data structures
//

def(L, elements\,
  primitive('L')
)

def(H, elements\,
  primitive('H')
)

def(X, elements\,
  primitive('X')
)

def(if, predicate, consequence, opposite?,
  primitive('if')
)

def(for, listOrInit, lambdaOrStopCond, incrementExpr?, body?,
  primitive('for')
)


def(join, list, separator?,
  primitive('join')
)

// Shell
//

def(prit, elements\,
  primitive('prit')
)

def(print, elements\,
  prit(elements\, "\n")
)

def(load, file,
  primitive('load')
)

// Package management
//

def(package, name, body,
  primitive('package')
)

def(import, name,
  primitive('import')
)

def(::, package, definition,
  primitive('::')
)

// Operators, order is establishing precedence
macro(`a = `b,
  if(applic?(a),
    if(fnName(a) == "@", 
      `(@!($(nthParam(a, 0)), $(nthParam(a,1)), $b)) ),
    `(=($a, $b))
  )
)

// Defining macrox as a shorthand form of macro where
// the body is always escaped.
macro(macrox(`exp, `body), `(macro($exp, `($body))))

macrox(`a && `b, &&($a, $b))
macrox(`a || `b, ||($a, $b))

macrox(`a == `b, ==($a, $b))
macrox(`a != `b, !=($a, $b))
macrox(`a < `b, <($a, $b))
macrox(`a <= `b, <=($a, $b))
macrox(`a > `b, >($a, $b))
macrox(`a >= `b, >=($a, $b))
macrox(`a =~ `b, =~($a, $b))

macrox(`a += `b, =($a, +($a, $b)))
macrox(`a -= `b, =($a, -($a, $b)))
macrox(`a + `b, +($a, $b))
macrox(`a - `b, -($a, $b))
macrox(`a * `b, *($a, $b))
macrox(`a / `b, /($a, $b))

// Standard parsing for foo@bar(baz) is foo@(bar(baz)). We want (foo@bar)(baz).
macro(`arr . `idx, 
  if(applic?(idx),
    if(params?(idx),
      `( @($arr, $(fnName(idx)))($<(params(idx))) ),
      `( @($arr, $(fnName(idx)))() )
    ),
    `(@($arr, $idx))
  )
)

macro(`pack :: `def, 
  if(applic?(def),
    if(params?(def),
      `( ::($pack, $(fnName(def)))($<(params(def))) ),
      `( ::($pack, $(fnName(def)))() )
    ),
    `(::($pack, $def))
  )
)

// TODO let with variable number of var/val pairs
macro(let(`var, `val, `block), `(lambda($var, $block)($val)))

LanguageErrors = [ReferenceError, NameError, CallError, TypeError]
