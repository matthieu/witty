module(Foundation, 

  // A few macros defining macros to get started
  macrop(macro(`exp, `body), 10, `(macrop($exp, 10, $body)));
  macro(macrox(`exp, `body), `(macrop($exp, 10, `($body))));
  macro(macropx(`exp, `priority, `body), `(macrop($exp, $priority, `($body))));

  // Arithmetic operators
  macrop(`a = `b, 1,
    if(applic?(a),
      if(fnName(a) == "@", 
        `(@!($(nthParam(a, 0)), $(nthParam(a,1)), $b)) ),
      `(=($a, $b))
    )
  )
  macropx(`a += `b, 1, $a = $a + $b);
  macropx(`a -= `b, 1, $a = $a - $b);
  macropx(`a << `b, 1, <<($a, $b));
  macropx(`a >> `b, 1, >>($a, $b));
  macropx(`a || `b, 2, ||($a, $b));
  macropx(`a && `b, 3, &&($a, $b));
  macropx(`a == `b, 4, ==($a, $b));
  macropx(`a <= `b, 5, <=($a, $b));
  macropx(`a >= `b, 5, >=($a, $b));
  macropx(`a < `b, 5, <($a, $b));
  macropx(`a > `b, 5, >($a, $b));
  macropx(`a + `b, 6, +($a, $b));
  macropx(`a - `b, 6, -($a, $b));
  macropx(`a * `b, 7, *($a, $b));
  macropx(`a / `b, 7, /($a, $b));

  // Index-based acces in container data structures (lists, string, hashes). Standard 
  // parsing for foo.bar(baz) is foo.(bar(baz)). We want (foo.bar)(baz).
  macro(`arr . `idx, 
    if(applic?(idx),
      if(empty?(params(idx)),
        `( @($arr, $(fnName(idx)))() ),
        `( @($arr, $(fnName(idx)))($^(params(idx))) )
      ),
      `(@($arr, $idx))
    )
  )

  // Access to module definitions from outside
  macro(`mod :: `def, 
    if(applic?(def),
      if(empty?(params(def)),
        `( ::($mod, $(fnName(def)))() ),
        `( ::($mod, $(fnName(def)))($^(params(def))) )
      ),
      `(::($mod, $def))
    )
  )

  macrox(unless(`cond, `body), if(!($cond), $body)) 

  foldl1 = lambda(fn, arr, foldl(fn, head(arr), tail(arr)))
  foldr1 = lambda(fn, arr, foldr(fn, head(arr), tail(arr)))

  map = lambda(fn, arr, foldr(lambda(x, ys, [fn(x)] + ys), [], arr))

  for = lambda(arr, l, 
    foldl(lambda(acc, x, l(x)), null, arr)
  )

  UnknownRef = { type: 'UnknownRef' }
  ArgumentError = { type: 'ArgumentError' }
  SysError = [UnknownRef, ArgumentError]

  macrox(catch(`err, `var?, `body?), [$err, lambda($var, $body)])
  head = lambda(a, a.0)
  tail = lambda(a, slice(a, 1))

  join = lambda(arr, sep?, 
    foldl1(
      lambda(a, b, 
        if(sep, a + sep + b, a + b)
      ), 
      arr
    )
  )

  split = lambda(str, sep,
    if(empty?(str), 
      [""],

      if(head(str) == sep,
        [""] + split(tail(str), sep),

        rest = split(tail(str), sep)
        [head(str) + head(rest)] + tail(rest)
      )
    )
  )
)

import(Foundation)
