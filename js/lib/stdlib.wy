// Operators, order is establishing precedence
macro(`a = `b,
  if(applic?(a),
    if(fnName(a) == "@", 
      `(@!($(nthParam(a, 0)), $(nthParam(a,1)), $b)) ),
    `(=($a, $b))
  )
)

macro(`a && `b, `(&&($a, $b)))
macro(`a || `b, `(||($a, $b)))

macro(`a == `b, `(==($a, $b)))
macro(`a != `b, `(!=($a, $b)))
macro(`a < `b, `(<($a, $b)))
macro(`a <= `b, `(<=($a, $b)))
macro(`a > `b, `(>($a, $b)))
macro(`a >= `b, `(>=($a, $b)))

macro(`a += `b, `(=($a, +($a, $b))))
macro(`a -= `b, `(=($a, -($a, $b))))
macro(`a + `b, `(+($a, $b)))
macro(`a - `b, `(-($a, $b)))
macro(`a * `b, `(*($a, $b)))
macro(`a / `b, `(/($a, $b)))

// Standard parsing for foo@bar(baz) is foo@(bar(baz)). We want (foo@bar)(baz).
macro(`arr @ `idx, 
  if(applic?(idx),
    if(params?(idx),
      `( @($arr, $(fnName(idx)))($<(params(idx))) ),
      `( @($arr, $(fnName(idx)))() )
    ),
    `(@($arr, $idx))
  )
)

macro(`pack :: `def, 
  if(applic?(def),
    if(params?(def),
      `( ::($pack, $(fnName(def)))($<(params(def))) ),
      `( ::($pack, $(fnName(def)))() )
    ),
    `(::($pack, $def))
  )
)

// TODO let with variable number of var/val pairs
macro(let(`var, `val, `block), `(lambda($var, $block)($val)))

